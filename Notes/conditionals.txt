==========================================================
    Notes on the General Structure of VMQ IF/ELSE Code
	  and the Conditional Evaluation Process
==========================================================
    We'll open up with an example.  Here is a very basic
    sample C++ program and the expected VMQ code that the
    compiler should generate:
	
    ========
    C++ Code
    ========
    #include <iostream>
    
    int main()
    {
	if(2 < 3 && 5 > 3)
	    cout << "true" << endl;
	else
	    cout << "false" << endl;
	
	return 0;
    }

    ===============
    Target VMQ Code
    ===============
    000 0
    002 1
    004 2
    006 3
    008 5
    010 "true"
    015 "\n"
    017 "false"
L0  $ 1 22
L1  # 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L2  l 004 008 4
L3  j 5			; COND BLOCK
L4  g 010 008 12
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L5  p #017
L6  c 0 -11
L7  ^ 2
L8  p #015		; FALSE BLOCK
L9  c 0 -11		; By having the false code first, we can usually avoid having
L10 ^ 2			; an extra jump statement after the last conditional op
L11 j 18
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L12 p #010
L13 c 0 -11
L14 ^ 2
L15 p #015		; TRUE BLOCK
L16 c 0 -11
L17 ^ 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L18 i 000 @/4
L19 h
    
    This is an improvement over the original approach I did for IF/ELSE, as the
    original relied on storing TRUE/FALSE results from relation ops in temporary 
    variables, then performing bit-wise logical ops on the boolean results 
    to determine which block of code to jump to.  This new approach uses no memory 
    and makes handling logical short-circuit evaluation more straight forward. This
    was something the previous implementation lacked, though it would have been
    undoubtedly complicated and relatively demanding with regards to memory usage.

    By comparison, here is an example of the approach I took toward the problem
    the first time around (global memory and initialization as before)...

L0  $ 1 22
L1  # 6
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L2  l 004 006 4
L3  i 000 /-4
L4  j 5
L5  i 002 /-4
L6  g 008 006 8		; COND BLOCK - About three times as long, and it uses local memory.
L7  i 000 /-6		;	       Also, does not incorporate short circuit evaluation.
L8  j 9			;	       Additionally, bitwise NOT is problematic with this approach.
L9  i 000 /-6		;	       (~ 002 /-4 :: /-4 == 0xFFFE == -2 (assuming twos complement).
L10 & /-4 /-6 /-4	;	       Basically, performing a VMQ NOT operation on our representation
L11 e /-4 002 19	;	       of TRUE(1) would not result in FALSE(0), due to it being bitwise)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L12 p #017
L13 c 0 -11
L14 ^ 2
L15 p #015		; FALSE BLOCK
L16 c 0 -11
L17 ^ 2
L18 j 24
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L19 p #010
L20 c 0 -11
L21 ^ 2			; TRUE BLOCK
L22 p #015
L23 c 0 -11
L24 ^ 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L25 i 000 @/4
L26 h
    

    ======================================
    Things to Note About Logical Operators
    ======================================
   
    OR/ANDs are handled a lot like ADDOP/MULOPs
    -------------------------------------------
    true || false && true	   3 + 5 * 2

	    true || false	   3 + 10

		     true	   13

        ANDs are performed first, then ORs
    -------------------------------------------


        Same with UNARY ops and NOT ops
    ---------------------------------------
    !true || false && true	-3 + 5 * 2
    
    false || false && true	-3 + 5 * 2

	    false && false	-3 + 10

		     false	 7
    ---------------------------------------

    Due to this, some of the same logic that applied
    to math ops can be applied to logical operations,
    since the trees will be structured the same. In the
    case of 2 < 3 && 5 > 3, the tree will look something
    like this:
		       =====
		       |AND|
		       =====
		      /     \
		     /	     \
		    /	      \
		  ===	      ===
		  |<|	      |>|
		  ===	      ===
		 /   \	     /   \
		/     \     /     \
       2       3   5	   3

    Due to the way the Target Language Syntax has been defined,
    we do not have to worry about a few conditional expressions
    that are commonly used in C++.

    For instance, the code below is invalid, since all conditional
    expressions must ultimately contain some sort of relational
    comparison between two operands (specifically some type of
    "simple_expression," as defined in the Target Language Syntax).
    
    ---------------------------
    Invalid code:
    |	|   |	|
    v	v   v	v
    int x = 5; 
    while(x)
    {
	.
	. // loop code
	.
	x -= 1;
    } 
    --------------------------
    Equivalent but valid code:
    |	|   |	|   |	|   |
    v	v   v	v   v	v   v
    int x = 5;
    while(x != 0)
    {
	.
	. // loop code
	.
	x -= 1;
    }

=========================================
    Now for something a bit trickier:
=========================================

    ========
    C++ code
    ========
    #include <iostream>

    int main()
    {
	int a, b, c, d;

	cin >> a >> b >> c >> d;

	if((a < b && b > c) || (d <= a && c > a))
	    cout << "true" << endl;
	else
	    cout << "false" << endl;

	return 0;
    }

    ===============
    Target VMQ code
    ===============
    000 0
    002 "true"
    007 "\n"
    009 "false"
    $ 1 14
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L1  # 10
L2  p #/-4
L3  c 0 -1	    ; a @ #/-4, b @ #/-6
L4  ^ 2		    ; c @ #/-8, d @ #/-10
L5  p #/-6
L6  c 0 -1	    ; get values for
L7  ^ 2		    ; a, b, c, and d
L8  p #/-8	    ; from the user
L9  c 0 -1
L10 ^ 2
L11 p #/-10 
L12 c 0 -1
L13 ^ 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	  LHS of OR: (a < b && b > c)	      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L14 l /-4 /-6 16    ; (jump to sibling_start)		    :: a < b ::
L15 j 17	    ; (jump to parent_rhs_start)	
L16 g /-6 /-8 26    ; (jump to true_start - short circuit)  :: b > c ::
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	  RHS of OR: (d <= a && c > a)	      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L17 g /-10 /-4 19   ; (jump to false_start - short circuit) :: d <= a :: ** see below **
L18 g /-8 /-4 26    ; (jump to true_start)		    :: c > a ::
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		  FALSE CODE		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L19 p #009
L20 c 0 -11
L21 ^ 2
L22 p #007	;   Print "false" and "\n" to stdout
L23 c 0 -11
L24 ^ 2
L25 j 32	;   Jump past the true code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		   TRUE CODE		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L26 p #002
L27 c 0 -11
L28 ^ 2
L29 p #007	;   Print "true" and "\n" to stdout
L30 c 0 -11
L31 ^ 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		  RETURN CODE		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L32 i 000 @/4
L33 h		;   return 0 and end program

    ===============================================
     (d <= a) and Unsupported Relational Operators
    ===============================================
    VMQ does not have any ops that are equivalent to less-than-or-equal-to(LTE), greater-than-or-equal-to(GTE), or not-equal-to(NEQ).
    Due to this, we have to be a bit crafty with regards to how we handle such cases when they are encountered in the cpp source file.

    A simple and effective solution to this is to simply use the complement of the operation, while switching the jump target from
    the normal target.

    For example, all of the other relational operations from the above example (a < b, b > c, c > a) use operators that are directly
    supported by VMQ.  When this is the case, the normal jump target is the continuation of the conditional code (i.e., NOT jumping
    to the false code) or in some cases short circuiting (either directly to the true code or to the RHS of the "parent" or current
    logical op). The code directly after the VMQ conditional is the code to execute when the conditional op evaluated to false, 
    typically (if not always) leading to the continuation of the conditional code or short circuiting to the false block or again to 
    the RHS of the "parent" or current logical op, depending on what the current and "parent" logical operators are.

    When an unsupported relational operator is encountered (i.e.: <=, >=, !=) we will simply use the logical complement of the unsupported
    relational operator and switch the jump target.  So for the case above, instead of evaluating whether or not (d <= a), we will just
    determine whether or not (d > a).  If (d > a) == true, then (d <= a) == false - and vice-versa.  If (d > a) == true, we do not want
    to continue evaluating the logical operation (the LHS of a logical AND operation is false, so the result is false regardless of the
    RHS).  Due to this, the jump target for the corresponding VMQ operation (g /-10 /-4 19, where 19 is the jump target) causes control
    to begin to execute the false code.  If (d > a) == false, then the program does not jump, and instead evaluates the next relational
    operation (c > a).  The result of (c > a) ultimately determines whether or not the false or true code is executing (assuming the LHS 
    of the OR operation did not short-circuit to executing the true code already).

    =====================
      Incorporating NOT
    =====================
    Working with the previous example, we will insert a NOT operation:

    ========
    C++ code
    ========
    #include <iostream>

    int main()
    {
	int a, b, c, d;

	cin >> a >> b >> c >> d;

	if(!(a < b && b > c) || (d <= a && c > a))
	    cout << "true" << endl;
	else
	    cout << "false" << endl;

	return 0;
    }

    The tree for the boolean expression should look like this:

			       OR
			    /      \
			 NOT	    AND
	        /	       /   \
		  AND	     <=     >
		 /   \		/  \   / \
		<     >    d    a c   a
	   / \   / \
      a   b b   c

    So how to handle the NOT?  How should the VMQ code differ?
    From De Morgans Law --> ~(X && Y) == (~X || ~Y)

    X and Y represent some sort of relational operation between two operands.
    Taking the complement of a relational operation means we switch the comparison
    to the complement of the original operator, just like we did for the (d <= a)
    operation from the previous example.

    We have a few options open to us in terms of implementation details.

    The most intuitive approach is to perform a pre-eval traversal through the tree.
    Upon encountering a NOT node, all of the descendant AND, OR, and relational nodes
    will be changed to their complement (AND -> OR, OR -> AND, etc.) until the entire
    subtree is traversed.  The NOT node will be removed, and the NOTs parent node will
    be directly connected to NOTs child.  If another NOT is encountered after the first,
    this NOT will be removed in the same manner as the first, and any descendents after
	will not be modified (two NOTs cancel each other out).

    A possibly more efficient approach would be to pass a NOT counter while doing the
    evaluation traversal.  Anytime (not_counter % 2 == 1), we'll perform evaluations
    as if we had applied De Morgans Law transformations on the appropriate nodes, 
    and when not_counter % 2 == 0 we'll evaluate as normal.

    Whether we actually change the structure of the tree or simply count the NOTs and
    adjust accordingly, the code generated will be as if the original tree looked like
    this:

			       OR
			     /	  \
			   /	    AND
			 /	       /   \
		    OR	      <=     >
		  /    \     /  \   / \
		<=     >=   d    a c   a
	   /  \   /  \
      a    b b    c

    ===============
    Target VMQ code
    ===============
    000 0
    002 "true"
    007 "\n"
    009 "false"
    $ 1 14
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L1  # 10
L2  p #/-4
L3  c 0 -1	    ; a @ #/-4, b @ #/-6
L4  ^ 2		    ; c @ #/-8, d @ #/-10
L5  p #/-6
L6  c 0 -1	    ; get values for
L7  ^ 2		    ; a, b, c, and d
L8  p #/-8	    ; from the user
L9  c 0 -1
L10 ^ 2
L11 p #/-10 
L12 c 0 -1
L13 ^ 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	  LHS of OR: (a <= b || b >= c)	      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L14 g /-4 /-6 16    ; (jump to sibiling_start)		    :: a <= b ::
L15 j 27	    ; (jump to true_start - short circuit)	
L16 l /-6 /-8 18    ; (jump to RHS_start)		    :: b >= c ::
L17 j 27	    ; (jump to true_start - short circuit)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	  RHS of OR: (d <= a && c > a)	      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L18 g /-10 /-4 20   ; (jump to false_start - short circuit) :: d <= a :: ** see below **
L19 g /-8 /-4 27    ; (jump to true_start)		    :: c > a ::
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		  FALSE CODE		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L20 p #009
L21 c 0 -11
L22 ^ 2
L23 p #007	;   Print "false" and "\n" to stdout
L24 c 0 -11
L25 ^ 2
L26 j 33	;   Jump past the true code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		   TRUE CODE		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L27 p #002
L28 c 0 -11
L29 ^ 2
L30 p #007	;   Print "true" and "\n" to stdout
L31 c 0 -11
L32 ^ 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;		  RETURN CODE		      ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
L33 i 000 @/4
L34 h		;   return 0 and end program


    =====================================================
     Roots, Parents, Logical Operators, and Jump Targets
    =====================================================
    Arguably, one of the most challenging aspects of generating VMQ code for
    conditional statements is determining where to jump to and when.  This is
    such a difficult task due to that fact that the code is being evaluated
    and generated in a linear fashion, so jump commands are being generated
    before the jump target has been generated - a proverbial leap of faith.

    I'll go ahead and give a complex example that will accentuate these challenges,
    then we'll step through it and see if we can develop a solution.

    This statement below should generate following tree:

						    ROOT
						     ||
    |----------------- LHS of ROOT ----------------| vv |---- RHS of ROOT ----|
    (!(x >= y) || (((x < y) || (x >= z)) && (z > y)) && !((y > x) || !(z >= x))

     --------------------------------------------------------------
     Tree generated by Bison parser from the bool_expression above:
     --------------------------------------------------------------
				        AND
				    /	     \
				  /		      NOT
			    /			     \
			  OR			      OR
		    /    \			    /    \
		   /      \	    	   >	   \
		  NOT	 AND		  / \	     \
		 /		/   \		 y   x	     NOT
		>=	   /     >			         /
	   /  \	  OR    / \		            >= 
      x    y  / \  z   y               /  \
			 <    >=			 	  z    x
			/ \   /  \
		   x   y x    z

     --------------------------------------------------------------
     An equivalent tree with the NOTs transformed out via DM's Law:
     --------------------------------------------------------------

				        AND
				    /	     \
				  /		       \
			    /			     \
			  OR			     AND
		    /    \				/   \
		   <	  \			  <=	 >=
		  / \	  AND		 /  \	/  \  
		 x   y	 /   \		y    x z    x       
			    /     >			    
			  OR	 / \			   
			 / \    z   y		  
			<   >=			 
		   / \  / \
		  x   y x  z

    Let's define the VMQ locations of the variables used:
		x @ #/-4, y @ #/-6, z @ #/-8

    We'll examine this second tree, as it'll be easier to work with.

    A stack will be used as we traverse the tree; AND/ORs will be pushed
    onto the stack when encountered, and popped off of the stack once
    evaluated.  This structure will help us direct jump targets.

    For example, let's look at the first relational that will be evaluated,
    (x < y).

    The parent of this relational node is an OR, so if (x < y) == true
    then the entire OR subtree is true, regardless of the RHS.  The parent
    of the OR subtree (also the root of the entire tree) is an AND.  Due to
    this, the jump target for (x < y)'s statement will be the beginning of
    the conditional code for the RHS of the root.  So if JT is the line
    number that marks the start of this code, then the generated statement
    will be (l /-4 /-6 JT).  Of course, we can't actually know what the line
    number will be ahead of time... or can we?

    Let's look at some cases to see if there's a set pattern that we can use
    to determine line count.

    =================================================
    Case 1:  AND SUBTREE with two relational children
    =================================================
					AND
				  /     \
		       REL_1   REL_2
		       /   \   /   \
		     lhs  rhs lhs  rhs

    ----------------------------------
    Here are the cases for REL_1 (LHS)
    ---------------------------------- 
    Supported VMQ Ops - 2 Statements:
    ----------------------------------
    case (<):	l lhs rhs REL_2_CODE
		j NEXT_COND_OR_FALSE_CODE
		
    case (>):	g lhs rhs REL_2_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (==):	e lhs rhs REL_2_CODE
		j NEXT_COND_OR_FALSE_CODE
    ----------------------------------

    Unsupported VMQ Ops - 1 Statement:
    ------------------------------------------
    case (<=):	g lhs rhs NEXT_COND_OR_FALSE_CODE
 
    case (>=):	l lhs rhs NEXT_COND_OR_FALSE_CODE

    case (!=):	e lhs rhs NEXT_COND_OR_FALSE_CODE
    ------------------------------------------

    ---------------------
    Cases for REL_2 (RHS)
    ---------------------
    Supported VMQ Ops - 2 Statements:
    --------------------------------------------
    case (<):	l lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (>):	g lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (==):	e lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE
    --------------------------------------------

    Unsupported VMQ Ops - 2 Statements:
    ---------------------------------------------
    case (<=):	g lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE
    
    case (>=):	l lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (!=):	e lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE
    ---------------------------------------------

    ================================================
    Case 2:  OR SUBTREE with two relational children
    ================================================
					 OR
				  /      \
		       REL_1    REL_2
		       /   \    /   \
		     lhs  rhs lhs  rhs
    
    ---------------
    Cases for REL_1
    ---------------
    Supported VMQ Ops - 1 Statements:
    --------------------------------------------
    case (<):	l lhs rhs NEXT_COND_OR_TRUE_CODE

    case (>):	g lhs rhs NEXT_COND_OR_TRUE_CODE

    case (==):	e lhs rhs NEXT_COND_OR_TRUE_CODE
    --------------------------------------------

    Unsupported VMQ Ops - 2 Statements:
    ---------------------------------------------
    case (<=):	g lhs rhs REL_2_CODE
		j NEXT_COND_OR_TRUE_CODE
    
    case (>=):	l lhs rhs REL_2_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (!=):	e lhs rhs REL_2_CODE
		j NEXT_COND_OR_TRUE_CODE
    ---------------------------------------------

    ---------------
    Cases for REL_2
    ---------------
    Supported VMQ Ops - 2 Statements:
    --------------------------------------------
    case (<):	l lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (>):	g lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (==):	e lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE
    --------------------------------------------

    Unsupported VMQ Ops - 2 Statements:
    ---------------------------------------------
    case (<=):	g lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (>=):	l lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (!=):	e lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE
    ---------------------------------------------
    
    ===================================================
    Case 3:  AND SUBTREE with one relational child(LHS)
    ===================================================
					AND
				  /     \
		      REL_1    (AND/OR) 
		      /   \	  	  /\
		    lhs   rhs	 /__\ --> REL_2 is left-most 
								  descendent of REL_1's
								  sibling.

    Note about REL_2:	In this case, we'll only evaluate REL_1,
						not REL_2.  REL_2 will be evaluated on its
						own later.  REL_2 will just be a jump
						destination for when REL_1 == true.
    ---------------			  
    Cases for REL_1
    ---------------
    Supported VMQ Ops - 2 Statements:
    -------------------------------------
    case (<):	l lhs rhs REL_2_START
		j NEXT_COND_OR_FALSE_CODE

    case (>):	g lhs rhs REL_2_START
		j NEXT_COND_OR_FALSE_CODE

    case (==):	e lhs rhs REL_2_START
		j NEXT_COND_OR_FALSE_CODE
    -------------------------------------

    Unsupported VMQ Ops - 1 Statement:
    ---------------------------------------------
    case (<=):	g lhs rhs NEXT_COND_OR_FALSE_CODE

    case (>=):	l lhs rhs NEXT_COND_OR_FALSE_CODE

    case (!=):	e lhs rhs NEXT_COND_OR_FALSE_CODE
    ---------------------------------------------

    ===================================================
    Case 4:  AND SUBTREE with one relational child(RHS)
    ===================================================
					AND
				  /     \
		    (AND/OR)   REL_2
		       /\      /   \
		      /__\   lhs   rhs
		    
    Relation on LHS of parent (AND) has already been evaluated.
    
    True target:    LHS of next conditional statement or true code.
    False target:   LHS of next conditional statement or false code.

    ---------------
    Cases for REL_2
    ---------------
    Supported VMQ Ops - 2 Statements:
    --------------------------------------------
    case (<):	l lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (>):	g lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (==):	e lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE
    --------------------------------------------

    Unsupported VMQ Ops - 2 Statements:
    ---------------------------------------------
    case (<=):	g lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (>=):	l lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (!=):	e lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE
    ---------------------------------------------

    ==================================================
    Case 5:  OR SUBTREE with one relational child(LHS)
    ==================================================
					 OR
				  /      \
		      REL_1     (AND/OR) 
		      /   \	   	   /\
		    lhs   rhs	  /__\ --> REL_2 is left-most 
								   descendent of REL_1's
								   sibling.

    Note about REL_2:	In this case, we'll only evaluate REL_1,
						not REL_2.  REL_2 will be evaluated on its
						own later.  REL_2 will just be a jump
						destination for when REL_1 == false.

    ---------------			  
    Cases for REL_1
    ---------------
    Supported VMQ Ops - 2 Statements:
    --------------------------------------------
    case (<):	l lhs rhs NEXT_COND_OR_TRUE_CODE
		j REL_2_START

    case (>):	g lhs rhs NEXT_COND_OR_TRUE_CODE
		j REL_2_START

    case (==):	e lhs rhs NEXT_COND_OR_TRUE_CODE
		j REL_2_START
    --------------------------------------------

    Unsupported VMQ Ops - 2 Statements:
    ------------------------------------
    case (<=):	g lhs rhs REL_2_START
		j NEXT_COND_OR_TRUE_CODE

    case (>=):	l lhs rhs REL_2_START
		j NEXT_COND_OR_TRUE_CODE

    case (!=):	e lhs rhs REL_2_START
		j NEXT_COND_OR_TRUE_CODE
    ------------------------------------

    ==================================================
    Case 6:  OR SUBTREE with one relational child(RHS)
    ==================================================
					 OR
				  /      \
		    (AND/OR)    REL_2
		       /\       /   \
		      /__\    lhs   rhs
		    
    Relation on LHS of parent (AND) has already been evaluated.
    
    True target:    LHS of next conditional statement or true code.
    False target:   LHS of next conditional statement or false code.

    ---------------
    Cases for REL_2
    ---------------
    Supported VMQ Ops - 2 Statements:
    --------------------------------------------
    case (<):	l lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (>):	g lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE

    case (==):	e lhs rhs NEXT_COND_OR_TRUE_CODE
		j NEXT_COND_OR_FALSE_CODE
    --------------------------------------------

    Unsupported VMQ Ops - 2 Statements:
    ---------------------------------------------
    case (<=):	g lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (>=):	l lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE

    case (!=):	e lhs rhs NEXT_COND_OR_FALSE_CODE
		j NEXT_COND_OR_TRUE_CODE
    ---------------------------------------------

    ===================================================
    Case 7:  AND/OR SUBTREE with no relational children
    ===================================================

				(AND/OR)
				/      \
		  (AND/OR)   (AND/OR)
		     /\			/\
		    /__\       /__\

    Nothing to be done here, just traverse the subtrees.


    ==========================================================
    NEXT_COND_OR_TRUE/FALSE_CODE? - Short Circuit Jump Targets
    ==========================================================

    Some of the placeholders for the jump statements above are pretty ambiguous.  How are
    we to know where to jump to exactly when short circuiting?  Let's take a look at the
    example we were about to go over before this line-counting digression.

					   AND  <--- 5
				    /	     \
				 /	       	    \
			  /	   2		       \
	1 --->	 OR	   |		         AND  <--- 4
	       /    \  v		        /   \
		  <		 \  		      <=	 >=
	     / \	 AND		     /  \	/  \  
	    x   y	/   \		    y    x z    x       
		       /     >			    
	  3 ---> OR	    / \			   
		    /   \  z   y		  
		   <     >=			 
		  / \   /  \
		 x   y x    z

    Short circuiting is possible for any AND/OR operation.  For AND, we short-circuit when the
    LHS evaluates to false since the RHS can no longer have any affect on the outcome of the AND.
    Similarly, we short-circuit on OR when the LHS evaluates to true.  
    ----------------------------------------------------------------------------------------------

    1)	The short-circuit here occurs when (x < y) evaluates to true.  The jump target for this
	operation when true is to the beginning of the LHS of (4), (y <= x).  The jump target
	for false is the next relational operation reached via in-order traversal of the tree,
	in this case the LHS of (3), (x < y).

    2)	The short-circuit here occurs when (x < y || x >= z) evaluates to false.  The jump target
	will be the to the LHS of (4), (y <= x).  The jump target for true is the same.

    3)	The short-circuit here occurs when (x < y) evaluates to true; the jump target will be
	the beginning of the RHS of (2), (z > y).  The jump target for false is the RHS relational
	operation, (x >= z).

    4)	The short-circuit here occurs when (y <= x) evaluates to false.  The jump target for false
	will be to the beginning of the false code block.  The jump target for true will be to the
	true code block.

    5)	The short-circuit here occurs when ((x < y) || ((x < y || x >= z) && z > y)) evaluates to
	false.  The jump target for false is the false code block.  The jump target for true is the
	LHS of (4), (y <= x).

    -----------------------------------------------------------------------------------------------
    There is a noticable pattern that can be taken advantage of to create a general 
    short-circuit-finding algorithm.  Let's take a look at some basic examples:

								OR
							   /
							AND
							/   \
						  OR    /\
						 /	   /__\
					   OR
					  /
	   START ---->  OR

    Let's say we start at the leaf OR (marked), and the LHS evaluates to true.  The short-circuit
    target can be determined in this case by traversing back up to the root (unwinding the stack).
    When we're short-circuiting from an OR, we keep going until one of two things occurs:  we
    encounter an AND node, or we reach a non-AND root.

    If we encounter an AND node, the we know that the short-circuit target for our leaf OR will be
    the left-most descendent node in the AND's right subtree.  If we reach the root and the node
    type is an OR, then the short-circuit target is the start of the true code block.

						      AND
							 /
						    OR
						   /  \
						 AND  /\
						/    /__\
					  AND
					 /
	  START ---->  AND
    
    The opposite applies to the short-circuit logic for AND nodes.  If the LHS evaluates to false
    for the leaf AND node, then we traverse back up to the root.  If an OR is encountered, then
    the short-circuit target is the left-most descendent of the OR node.  If the root is reached
    and the root is an AND node, then the short-circuit target is start of the false code block.

    It should be noted that for OR nodes, the short-circuit jump target will be the same as the
    jump target for the RHS relational operation evaluating to true.  For AND nodes, the
    short-circuit jump target will be the same as the jump target for the RHS relational operation
    evaluating to false.

    This doesn't really apply to the RHS of any subtree:

				    AND
				       \
						OR
				       /  \
				      /   AND
				     /\	    \
				    /__\    AND
							  \
					          AND <---- START

    Here, the short-circuit target from the marked node is always the false code block.

    If we use a stack to track short-circuit candidates then we can apply this rule:

    When evaluating a AND/OR node's left subtree, push the root of the subtree onto 
    the stack.  After that, pop it off the stack when evaluating that same AND/OR 
    node's right subtree.  

    When we need to find a short-circuit node, we start at the top of the stack until
    we find one (for AND nodes, we'll be looking for the first OR node in the stack; 
    vice-versa for OR nodes).  If the stack is empty or we can't find the node we're 
    looking for, then we know that the short-circuit target is the true/false code 
    block for the OR/AND node, respectively.

    -------------------------------------------------------------------------------
    With this analysis done, I think we are ready to define implementation details.
    -------------------------------------------------------------------------------
    
    ======================
    Useful Data Structures
    ======================

    AND/OR node data structure:

    // Defined in AST.h, along with accompanying creation function.
    struct logic_node
    {
	int nodetype;	// AND/OR
	unsigned int line_start;    // Starting VMQ line number of LHS relational code.
	struct AST_node* lhs, *rhs; // children of logic node (OR, AND, RELOP, or NULL)
	struct logic_node* sc_target, *t_target, *f_target; /* see below */
    };

    For the pointers-to-logic_node, a few constraints hold...

    (sc_target == t_target && nodetype == OR) != (sc_target == f_target && nodetype == AND)

    When nodetype == OR, f_target will be set to the left-most logic_node descendent of the node's 
    youngest OR ancestor or it will be set to NULL to indicate that the false jump target is the 
    false code block. t_target will be set to the left_most logic_node descendent of the node's 
    youngest AND ancestor, or it will be set to NULL to indicate that the true jump target is the
    true code block.

    When nodetype == AND, t_target will be set to the left-most logic_node descendent of the node's
    youngest AND ancestor or it will be set to NULL to indicate that the true jump target is the true 
    code block.  f_target will be set to the left_most logic_node descendent of the node's youngest
    OR ancestor, or it will be set to NULL to indicate that the false jump target is the false code
    block if no OR ancestor exists.

    // Defined in data_lists.h, along with accompanying push/pop functions.
    struct logic_stack_node
    {
	struct logic_node* val;
	struct logic_stack* next;
    };

    The logic_stack will be used to find short-circuit and true/false jump targets, as described
    in the corresponding section above.

    ================
    Useful Functions
    ================

    void DMTransformTree(struct logic_node* root, unsigned int not_count);
	- This will perform the De Morgans Law transformation on the tree as described in the
	  notes above.  This approach will simplify the remaining tasks at hand.  This should
	  be called prior to logic node configuration (see function below).

    unsigned int configureLogicNodes(struct logic_node* root);
	- This will set the line_start values for each applicable logic_node in the tree.
	    - Non-applicable logic_nodes are any nodes where both children are logic_nodes.
	- This function will also set the sc_target, t_target, and f_target pointers.
	- Returns the total number of lines that will be generated upon evaluation.

    struct logic_node* findShortCircuitTarget(struct logic_node* ln);
	- This will return the address of a logic_node that is the short-circuit target of the
	  passed logic node, or NULL (where NULL indicates the true/false code block, depending
	  on the passed logic_node's type).
	! Given that we know that sc_target will always be equivalent to t_target or f_target,
	  depending on the nodetype, this will probably not be implemented.

    struct logic_node* findTrueTarget(struct logic_node* ln);
	- This will find and return the logic_node whose line_start is the true jump target.
	  If one cannot be found, then NULL will be returned to indicate that the jump target
	  is the start of the true code block.

    struct logic_node* findFalseTarget(struct logic_node* ln);
	- This will find and return the logic_node whose line_start is the false jump target.
	  If one cannot be found, then NULL will be returned to indicate that the jump target
	  is the start of the false code block.
    
    ======================================
    General Routine for If/Else Evaluation
    ======================================

    void evalIf(struct ctrl_node* a)
    {
	struct logic_node* cond_code = a->c;
	struct AST_node* true_code = a->t;
	struct AST_node* false_code = a->f;

	struct func_list_node* func = CURRENT_FUNC;

	if(cond_code->nodetype == NOT)
	{
	    // It's possbile that the conditional tree starts with a NOT,
	    // so we'll need to adjust if that's the case, as DMTransformTree()
	    // assumes the root node is either an AND or an OR.
	    DMTransformTree(cond_code->l, 1);
	    cond_code = cond_code->l;
	}
	else
	    DMTransformTree(cond_code, 0);

	// Set up the logic node structures in preparation for evaluation,
	// get the number of lines that the code generation will create.
	unsigned int cond_count = configureLogicNodes(a);

	// Conditional code is generated last, so we'll need to store where
	// we'll end up inserting into the statement list after generation.
	struct VMQ_list_node* insert_pt = func->VMQ_data.stmt_list_tail;

	// Go ahead and add to the stmt count and line number so that
	// we can properly store the line numbers that false and true start on.
	func->VMQ_data.stmt_count += cond_count;
	func->VMQ_data.quad_end_line += cond_count;
	
	// Store the line number that the false code will start on. 
	unsigned int false_line_start = func->VMQ_data.quad_end_line + 1;
	eval(a->f);

	// Store the line number that the true code will start on.
	unsigned int true_line_start = func->VMQ_data.quad_end_line + 1;
	eval(a->t);

	// appendToVMQList() is dependent on CURRENT_FUNC, so we'll create
	// a temporary func_list_node and use that while we're evaluating
	// the conditional code.
	struct func_list_node* temp = malloc(sizeof(struct func_list_node));
	temp->VMQ_data.stmt_count = orig_cur_line - func->VMQ_data.quad_start_line;
	temp->VMQ_data.quad_end_line = orig_cur_line;

	// Generate conditional code using the temporary function to store the results.
	CURRENT_FUNC = temp;
	evalConditional(cond, true_line_start, false_line_start);
	
	// Restore CURRENT_FUNC.
	CURRENT_FUNC = func;

	// Insert the generated conditional code into the final list.
	temp->VMQ_data.stmt_list_tail->next = insert_ptr->next;
	insert_ptr->next = temp->VMQ_data.stmt_list_head;

	// Free up allocated memory.
	free(temp);
    }
