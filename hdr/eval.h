#ifndef EVAL_H_
#define EVAL_H_

#include "AST.h"
#include "helper_functions.h"
#include "parser.tab.h"

/* Recursively evaluates nodes in the AST Tree generated by Yacc parsing the src file */
void eval(struct AST_node* a);

// Helper functions for eval to help break up the work load.
void evalReturn(struct AST_node* a);
void evalIf(struct AST_node* a);
void evalWhile(struct AST_node* a);
void evalInput(struct AST_node* a);
void evalOutput(struct AST_node* a);
void evalAssignOp(struct AST_node* a);
void evalIncOp(struct AST_node* a);
unsigned int evalArrAccess(struct AST_node* a);
void evalFuncCall(struct AST_node* a);
unsigned int evalAddOp(struct AST_node* a);
unsigned int evalMulOp(struct AST_node* a);

static inline unsigned int getNewTempVar(unsigned int type)
{
    unsigned int* cur_addr = &CURRENT_FUNC->VMQ_data.tempvar_cur_addr;
    unsigned int* cur_size = &CURRENT_FUNC->VMQ_data.tempvar_cur_size;
    unsigned int* max_size = &CURRENT_FUNC->VMQ_data.tempvar_max_size;

    if(type == INT)
    {	// VMQ integers are 16 bits (2 bytes)
	*cur_size += VMQ_INT_SIZE;
	
	// If cur_size was zero before the above op, don't change cur_addr (it's already set to the correct addr)
	if(*cur_size - VMQ_INT_SIZE)
	    *cur_addr += VMQ_INT_SIZE;    
    }
    else if(type == ADDR)
    {	// VMQ addresses are 16 bits (2 bytes)
	*cur_size += VMQ_ADDR_SIZE;
	
	if(*cur_size - VMQ_ADDR_SIZE)
	    *cur_addr += VMQ_ADDR_SIZE;
    }
    else if(type == FLOAT)
    {	// VMQ floats are 32 bits (4 bytes)
	if(*cur_size)
	{
	    *cur_size += (*cur_addr % VMQ_FLT_SIZE) ? VMQ_FLT_SIZE : VMQ_ADDR_SIZE + VMQ_FLT_SIZE;
	    *cur_addr += (*cur_addr % VMQ_FLT_SIZE) ? (*cur_addr % VMQ_FLT_SIZE) : VMQ_FLT_SIZE;
	}
	else // No temporary variables are current in use
	{
	    *cur_size += (*cur_addr % VMQ_FLT_SIZE) ? VMQ_FLT_SIZE + VMQ_ADDR_SIZE : VMQ_FLT_SIZE;
	    *cur_addr += (*cur_addr % VMQ_FLT_SIZE) ? (*cur_addr % VMQ_FLT_SIZE) : 0;
	}
    }

/*
===================================================================================================
	Special Case - Temporary Floating Point Variables and Memory Address Alignment
	-  Floating point values/variables must be stored at memory addresses which  -
	-		   are divisible by 4, per VMQ specifications		     -
===================================================================================================
Case 1:  Adding float tempvar, next 2-byte slot is aligned (i.e., *cur_addr % VMQ_FLT_SIZE != 0)

	      v ---> destination memory addr
    [INT]   [	]   [	]   [	]   ...
     -2	     -4	     -6	     -8
      ^			Required adjustments for adding float tempvar:
      |			*cur_size += VMQ_FLT_SIZE		(i.e., += 4)
      |			*cur_addr += (*cur_addr % VMQ_FLT_SIZE) (i.e., += 2)
   cur_addr
====================================================================================================
Case 2:  Adding float tempvar, next 2-byte slot is NOT aligned (i.e., *cur_addr % VMQ_FLT_SIZE == 0)

			      v ---> destination memory addr
    [INT]   [INT]   [	]   [	]   ...
     -2	     -4	     -6	     -8
	      ^		Required adjustments for adding float tempvar:
	      |		*cur_size += VMQ_ADDR_SIZE + VMQ_FLT_SIZE   (i.e., += 6)
	      |		*cur_addr += VMQ_FLT_SIZE		    (i.e., += 4)
	   cur_addr
====================================================================================================
Case 3:  Adding float tempvar, no temporary variables are in use - starting addr is aligned
	    (this can happen when function has declared local variables (e.g., int x;)

      v ---> destination memory addr
    [	]   [	]   [	]   ...
     -4	     -6	     -8	
      ^			Required adjustments for adding float tempvar:
      |			*cur_size += VMQ_FLT_SIZE		(i.e., += 4)
      |			*cur_addr += 0
   cur_addr
====================================================================================================
Case 4:  Adding float tempvar, no temporary variables are in use - starting addr NOT aligned

	      v ---> destination memory addr
    [	]   [	]   [	]   [	]   ...
     -2	     -4	     -6	     -8
      ^			Required adjustments for adding float tempvar:
      |			*cur_size += VMQ_FLT_SIZE + VMQ_ADDR_SIZE   (i.e., += 6)
      |			*cur_addr += (*cur_addr % VMQ_FLT_SIZE)	    (i.e., += 2)
   cur_addr
====================================================================================================
*/

    // If we've used up a record number of bytes, set max_size so we can 
    // track required amount of local memory needed for the current function.
    if(*cur_size > *max_size)
	*max_size = *cur_size;

    return *cur_addr;
}

static inline void restoreTempVarState(unsigned int addr, unsigned int size)
{
    CURRENT_FUNC->VMQ_data.tempvar_cur_addr = addr;
    CURRENT_FUNC->VMQ_data.tempvar_cur_size = size;
}

#endif
